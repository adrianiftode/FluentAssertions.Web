namespace FluentAssertions.Web;

/// <summary>
/// Contains a number of methods to assert that an <see cref="HttpResponseMessage"/> is in the expected state related to HTTP Bad Request response
/// </summary>
public class BadRequestAssertions : HttpResponseMessageAssertions
{
    private const string ErrorsPropertyName = "errors";

    /// <summary>
    /// Initialized a new instance of the <see cref="BadRequestAssertions"/>
    /// class.
    /// </summary>
    /// <param name="value">The subject value to be asserted.</param>
    /// <param name="assertionChain">The assertion chain to build and manage assertions.</param>
    public BadRequestAssertions(HttpResponseMessage value, AssertionChain assertionChain) : base(value, assertionChain)
    {
    }

    /// <summary>
    /// Returns the type of the subject the assertion applies on.
    /// </summary>
    protected override string Identifier => "BadRequest";

    /// <summary>
    /// Asserts that a Bad Request HTTP response content contains an error message identifiable by an expected field name and a wildcard error text.
    /// </summary>
    /// <remarks>
    /// This assertion considers the HTTP response content a JSON generated by the ASP.NET Core 3.0 framework or less
    /// </remarks>
    /// <param name="expectedErrorField">
    /// The expected field name.
    /// </param>
    /// <param name="expectedWildcardErrorMessage">
    /// The wildcard pattern with which the error field associated error message is matched, where * and ? have special meanings.
    /// </param>
    /// <param name="because">
    /// A formatted phrase as is supported by <see cref="string.Format(string,object[])" /> explaining why the assertion
    /// is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
    /// </param>
    /// <param name="becauseArgs">
    /// Zero or more objects to format using the placeholders in <see paramref="because" />.
    /// </param>
    [CustomAssertion]
    public AndConstraint<BadRequestAssertions> HaveError(string expectedErrorField, string expectedWildcardErrorMessage,
        string because = "", params object[] becauseArgs)
    {
        Guard.ThrowIfArgumentIsNullOrEmpty(expectedErrorField, nameof(expectedErrorField), "Cannot verify having an error against a <null> or empty field name.");
        Guard.ThrowIfArgumentIsNullOrEmpty(expectedWildcardErrorMessage, nameof(expectedWildcardErrorMessage), "Cannot verify having an error against a <null> or empty wildcard error message.");

        Func<Task<JsonDocument>> jsonFunc = () => Subject.GetJsonDocument();
        using var json = jsonFunc.ExecuteInDefaultSynchronizationContext().GetAwaiter().GetResult();

        var errorsProperty = json.GetPropertiesByName(ErrorsPropertyName).ToList();
        var hasErrorsProperty = errorsProperty.Any();
        var fieldsOfErrorsProperty = json.GetChildrenNames(ErrorsPropertyName);
        var allFields = json.GetChildrenNames("");
        var fields = hasErrorsProperty ? fieldsOfErrorsProperty : allFields;

        CurrentAssertionChain
            .BecauseOf(because, becauseArgs)
            .ForCondition(fields.Any(field => string.Equals(field, expectedErrorField, StringComparison.OrdinalIgnoreCase)))
            .FailWith("Expected {context:response} " +
                      "to contain an error message related to the {0} field, but was not found." +
                      "{1}",
                expectedErrorField, Subject);

        var errorsMessages = hasErrorsProperty ? errorsProperty.First().GetStringValuesOf(expectedErrorField) : json.GetStringValuesOf(expectedErrorField);
        var matchFound = errorsMessages.Any(errorMessage =>
        {
            using var scope = new AssertionScope();
            errorMessage.Should().Match(expectedWildcardErrorMessage);
            return !scope.Discard().Any();
        });

        CurrentAssertionChain
                    .BecauseOf(because, becauseArgs)
                    .ForCondition(matchFound)
                    .FailWith("Expected {context:response} to contain " +
                              "the error message {0} related to the {1} field, " +
                              "but no such message was found in the actual error messages list: " +
                              "{2}",
                        expectedWildcardErrorMessage,
                        expectedErrorField,
                        Subject);

        return new AndConstraint<BadRequestAssertions>(this);
    }

    /// <summary>
    /// Asserts that a Bad Request HTTP response content contains only a single error message identifiable by an expected field name and a wildcard error text.
    /// </summary>
    /// <remarks>
    /// This assertion considers the HTTP response content a JSON generated by the ASP.NET Core 3.0 framework or less
    /// </remarks>
    /// <param name="expectedErrorField">
    /// The expected field name.
    /// </param>
    /// <param name="expectedWildcardErrorMessage">
    /// The wildcard pattern with which the error field associated error message is matched, where * and ? have special meanings.
    /// </param>
    /// <param name="because">
    /// A formatted phrase as is supported by <see cref="string.Format(string,object[])" /> explaining why the assertion
    /// is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
    /// </param>
    /// <param name="becauseArgs">
    /// Zero or more objects to format using the placeholders in <see paramref="because" />.
    /// </param>

    [CustomAssertion]
    public AndConstraint<BadRequestAssertions> OnlyHaveError(string expectedErrorField, string expectedWildcardErrorMessage,
        string because = "", params object[] becauseArgs)
    {
        Guard.ThrowIfArgumentIsNullOrEmpty(expectedErrorField, nameof(expectedErrorField), "Cannot verify having only an error against a <null> or empty field name.");
        Guard.ThrowIfArgumentIsNullOrEmpty(expectedWildcardErrorMessage, nameof(expectedWildcardErrorMessage), "Cannot verify having only an error against a <null> or empty wildcard error message.");

        Func<Task<JsonDocument>> jsonFunc = () => Subject.GetJsonDocument();
        using var json = jsonFunc.ExecuteInDefaultSynchronizationContext().GetAwaiter().GetResult();

        var errorsProperty = json.GetPropertiesByName(ErrorsPropertyName).ToList();
        var hasErrorsProperty = errorsProperty.Any();
        var fieldsOfErrorsProperty = json.GetChildrenNames(ErrorsPropertyName);
        var allFields = json.GetChildrenNames("");
        var fields = hasErrorsProperty ? fieldsOfErrorsProperty : allFields;

        CurrentAssertionChain
            .BecauseOf(because, becauseArgs)
            .ForCondition(fields.Any(field => string.Equals(field, expectedErrorField, StringComparison.OrdinalIgnoreCase)))
            .FailWith("Expected {context:response} " +
                      "to contain an error message related to the {0} field, but was not found." +
                      "{1}",
                expectedErrorField, Subject);

        var parent = hasErrorsProperty ? ErrorsPropertyName : json.GetParentKey(expectedErrorField);
        var children = json.GetChildrenNames(parent);

        CurrentAssertionChain
            .BecauseOf(because, becauseArgs)
            .ForCondition(children.Count() == 1)
            .FailWith("Expected {context:response} " +
                      "to only contain an error message related to the {0} field, but more than this one was found." +
                      "{1}",
                expectedErrorField, Subject);

        var values = json.GetStringValuesOf(expectedErrorField);
        var expectedWildcardErrorMessageMatchFound = values.Any(headerValue =>
        {
            using var scope = new AssertionScope();
            headerValue.Should().Match(expectedWildcardErrorMessage);
            return !scope.Discard().Any();
        });

        CurrentAssertionChain
                    .BecauseOf(because, becauseArgs)
                    .ForCondition(expectedWildcardErrorMessageMatchFound)
                    .FailWith("Expected {context:response} to contain " +
                              "the error message {0} related to the {1} field, " +
                              "but no such message was found in the actual error messages list: " +
                              "{2}",
                        expectedWildcardErrorMessage,
                        expectedErrorField,
                        Subject);

        CurrentAssertionChain
            .BecauseOf(because, becauseArgs)
            .ForCondition(values.Count() == 1)
            .FailWith("Expected {context:response} " +
                      "to only contain an error message related to the {0} field and message {1}, but more than this one was found." +
                      "{2}",
                expectedErrorField, expectedWildcardErrorMessage, Subject);

        return new AndConstraint<BadRequestAssertions>(this);
    }

    /// <summary>
    /// Asserts that a Bad Request HTTP response content does not contain an error message identifiable by an expected field name.
    /// </summary>
    /// <remarks>
    /// This assertion considers the HTTP response content a JSON generated by the ASP.NET Core 3.0 framework or less
    /// </remarks>
    /// <param name="expectedErrorField">
    /// The expected field name.
    /// </param>
    /// <param name="because">
    /// A formatted phrase as is supported by <see cref="string.Format(string,object[])" /> explaining why the assertion
    /// is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
    /// </param>
    /// <param name="becauseArgs">
    /// Zero or more objects to format using the placeholders in <see paramref="because" />.
    /// </param>

    [CustomAssertion]
    public AndConstraint<BadRequestAssertions> NotHaveError(string expectedErrorField, string because = "", params object[] becauseArgs)
    {
        Guard.ThrowIfArgumentIsNullOrEmpty(expectedErrorField, nameof(expectedErrorField), "Cannot verify not having an error against a <null> or empty field name.");

        Func<Task<JsonDocument>> jsonFunc = () => Subject.GetJsonDocument();
        using var json = jsonFunc.ExecuteInDefaultSynchronizationContext().GetAwaiter().GetResult();

        var errorsProperty = json.GetPropertiesByName(ErrorsPropertyName).ToList();
        var hasErrorsProperty = errorsProperty.Any();
        var fieldsOfErrorsProperty = json.GetChildrenNames(ErrorsPropertyName);
        var allFields = json.GetChildrenNames("");
        var fields = hasErrorsProperty ? fieldsOfErrorsProperty : allFields;

        CurrentAssertionChain
            .BecauseOf(because, becauseArgs)
            .ForCondition(!fields.Any(c => string.Equals(c, expectedErrorField, StringComparison.OrdinalIgnoreCase)))
            .FailWith("Expected {context:response} " +
                      "to not contain an error message related to the {0} field, but was found.{1}",
                expectedErrorField, Subject);

        return new AndConstraint<BadRequestAssertions>(this);
    }

    /// <summary>
    /// Asserts that a Bad Request HTTP response content contains an error message identifiable by an wildcard error text.
    /// </summary>
    /// <param name="expectedWildcardErrorMessage">
    /// The wildcard pattern with which the error field associated error message is matched, where * and ? have special meanings.
    /// </param>
    /// <param name="because">
    /// A formatted phrase as is supported by <see cref="string.Format(string,object[])" /> explaining why the assertion
    /// is needed. If the phrase does not start with the word <i>because</i>, it is prepended automatically.
    /// </param>
    /// <param name="becauseArgs">
    /// Zero or more objects to format using the placeholders in <see paramref="because" />.
    /// </param>

    [CustomAssertion]
    public AndConstraint<BadRequestAssertions> HaveErrorMessage(string expectedWildcardErrorMessage,
        string because = "", params object[] becauseArgs)
    {
        Guard.ThrowIfArgumentIsNullOrEmpty(expectedWildcardErrorMessage, nameof(expectedWildcardErrorMessage), "Cannot verify having an error against a <null> or empty wildcard error message.");

        Func<Task<JsonDocument>> jsonFunc = () => Subject.GetJsonDocument();
        using var json = jsonFunc.ExecuteInDefaultSynchronizationContext().GetAwaiter().GetResult();

        var errorsPropertyList = json.GetPropertiesByName(ErrorsPropertyName).ToList();
        var hasErrorsProperty = errorsPropertyList.Any();
        var errorsProperty = errorsPropertyList.FirstOrDefault();
        var allErrors = hasErrorsProperty ? json.GetChildrenNames(ErrorsPropertyName).SelectMany(field => errorsProperty.GetStringValuesOf(field)) : json.GetChildrenNames("").SelectMany(field => json.GetStringValuesOf(field));
        
        var matchFound = allErrors.Any(errorMessage =>
        {
            using var scope = new AssertionScope();
            errorMessage.Should().Match(expectedWildcardErrorMessage);
            return !scope.Discard().Any();
        });

        CurrentAssertionChain
                    .BecauseOf(because, becauseArgs)
                    .ForCondition(matchFound)
                    .FailWith("Expected {context:response} to contain " +
                              "the error message {0}, " +
                              "but no such message was found in the actual error messages list: " +
                              "{1}",
                        expectedWildcardErrorMessage,
                        Subject);

        return new AndConstraint<BadRequestAssertions>(this);
    }
}